# 小约定App - AI集成方案（MVP使用云端API，后续支持端侧）

## 一、AI模型选型

### MVP阶段：Kimi k2模型API

#### 选择理由
- **超强理解能力**：k2-math领先数学推理，k2-reasoning强大逻辑推理
- **中文原生**：中文理解和生成能力业界顶尖
- **长上下文**：支持1M tokens超长上下文，适合复杂对话
- **API接入简单**：快速集成，降低MVP开发成本
- **成本可控**：按需付费，初期成本低

#### API接入方案
- **接入方式**：HTTPS REST API
- **认证方式**：API Key认证
- **调用限制**：根据套餐配置QPS和TPD限制
- **计费模式**：按token使用量计费

#### 不同平台的调用策略
| 平台 | 调用方式 | 优势 | 备注 |
|------|----------|------|------|
| 微信小程序 | 云函数中转 | 安全，API Key不暴露 | 需配置云函数 |
| H5 Web | 后端中转 | 统一管理，便于监控 | 需部署后端服务 |
| React Native | 直接调用/后端中转 | 灵活，可选择 | 建议后端中转 |

### 未来演进：端侧模型

#### 阶段规划
1. **Phase 1 (MVP)**：Kimi k2 API，验证功能和用户需求
2. **Phase 2 (v2.0)**：支持端侧模型下载，用户可选
3. **Phase 3 (v3.0)**：云端+端侧混合，智能切换

#### 端侧候选模型
- **Qwen3-0.6B**：轻量级，适合移动设备
- **Gemma-2B**：Google出品，性能均衡
- **Phi-3-mini**：微软出品，推理能力强

## 二、API接入架构

### 微信小程序架构

#### 云函数设计
```javascript
// cloudfunctions/kimi-ai/index.js
exports.main = async (event, context) => {
  const { action, data } = event;
  
  switch(action) {
    case 'parsePromise':
      return await parsePromiseText(data);
    case 'generateMilestones':
      return await generateMilestones(data);
    case 'optimizeContent':
      return await optimizeContent(data);
    default:
      return { error: 'Unknown action' };
  }
};
```

#### 调用封装
```typescript
// src/services/ai/kimi.ts
class KimiAIService {
  async callCloudFunction(action: string, data: any) {
    return await Taro.cloud.callFunction({
      name: 'kimi-ai',
      data: { action, data }
    });
  }
  
  async parsePromise(text: string) {
    const result = await this.callCloudFunction('parsePromise', { text });
    return this.formatPromiseData(result);
  }
}
```

### H5/RN架构

#### 后端API网关
```typescript
// backend/api/ai-gateway.ts
@Controller('/api/ai')
export class AIGatewayController {
  @Post('/parse')
  @RateLimit({ points: 10, duration: 60 })
  async parsePromise(@Body() dto: ParsePromiseDto) {
    return await this.kimiService.parsePromise(dto);
  }
  
  @Post('/optimize')
  @RateLimit({ points: 5, duration: 60 })
  async optimizeContent(@Body() dto: OptimizeDto) {
    return await this.kimiService.optimize(dto);
  }
}
```

#### 前端调用
```typescript
// src/services/ai/api-client.ts
class AIAPIClient {
  private baseURL = process.env.API_BASE_URL;
  
  async parsePromise(text: string) {
    const response = await fetch(`${this.baseURL}/api/ai/parse`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.getToken()}`
      },
      body: JSON.stringify({ text })
    });
    return response.json();
  }
}
```

## 三、API调用优化

### 请求优化策略

#### Token优化
- **Prompt工程**：精简prompt，减少token消耗
- **上下文管理**：只传必要上下文，避免冗余
- **流式响应**：支持SSE，提升用户体验

#### 缓存策略
- **结果缓存**：相似输入复用结果（Redis/内存）
- **模板缓存**：常用模板预生成
- **本地缓存**：客户端缓存常用结果

#### 限流保护
- **用户级限流**：每用户每分钟10次
- **全局限流**：总QPS不超过100
- **降级策略**：高峰期返回简化结果

### 成本控制

#### 计费监控
```typescript
// 成本监控中间件
@Injectable()
export class CostMonitorMiddleware {
  async use(req: Request, res: Response, next: NextFunction) {
    const startTokens = await this.getTokenCount();
    
    await next();
    
    const endTokens = await this.getTokenCount();
    const cost = this.calculateCost(endTokens - startTokens);
    
    // 记录成本
    await this.logCost({
      userId: req.user.id,
      tokens: endTokens - startTokens,
      cost,
      endpoint: req.path
    });
  }
}
```

#### 成本优化措施
1. **智能路由**：简单任务用轻量模型
2. **批量处理**：合并相似请求
3. **异步处理**：非实时任务排队处理
4. **用户分级**：免费用户限制调用次数

## 四、核心应用场景

### 1. AI快速创建（核心场景）

#### 一句话创建约定
- **输入方式**：自然语言/语音/图片
- **处理流程**：
  1. AI解析提取关键信息
  2. 识别缺失信息
  3. 一次性展示待补充项
  4. 智能生成里程碑和TODO
  5. 一键创建完成

#### 输入输出示例
```yaml
示例1:
  输入: "我要和女朋友一起学英语"
  AI解析:
    - 参与人: [我, 女朋友]
    - 目标: 学英语
    - 关系: 情侣
  一次性补充:
    - 学习时长: [1周, 2周, 1个月⭐, 3个月]
    - 每日时间: [30分钟⭐, 45分钟, 60分钟]
    - 学习时段: [早晨, 晚上⭐, 睡前]
    - 打卡方式: [学习笔记, 录音, 互相确认⭐]
  自动生成:
    - 里程碑: 每周掌握50个单词
    - TODO: 每日单词+口语练习

示例2:
  输入: "每天早上6点起床跑步"
  AI解析:
    - 参与人: [我]
    - 目标: 跑步
    - 时间: 每天早上6点
  一次性补充:
    - 跑步距离: [3公里, 5公里⭐, 10公里]
    - 持续时间: [1周, 1个月⭐, 3个月]
    - 打卡方式: [运动数据⭐, 自拍, 轨迹记录]
  自动生成:
    - 每周目标: 累计跑步35公里
    - 提醒: 5:30起床准备
```

### 2. 智能信息提取

#### 实体识别能力
- **人物识别**：我、女朋友、老婆、孩子、朋友、同事
- **时间识别**：今天、明天、本周、下周五、一个月内
- **频率识别**：每天、隔天、每周、工作日、周末
- **目标识别**：动词+名词组合（学英语、减重、读书）
- **数量识别**：5公斤、30分钟、100页、10公里

#### 关系类型推断
```javascript
// 关系推断逻辑
function inferRelationType(participants, content) {
  if (participants.length === 1) {
    return 'personal'; // 个人目标
  }
  
  if (hasKeywords(['女朋友', '男朋友', '老婆', '老公'])) {
    return 'couple'; // 情侣关系
  }
  
  if (hasKeywords(['孩子', '儿子', '女儿', '宝宝'])) {
    return 'parent_child'; // 亲子关系
  }
  
  if (participants.length > 2) {
    return 'group'; // 团队关系
  }
  
  return 'custom'; // 自定义关系
}
```

### 3. 智能补全策略

#### 一次性展示原则
- **不打扰**：所有待补充项一屏展示
- **预填充**：每项都有AI建议的默认值
- **可跳过**：非必填项可以忽略
- **快速完成**：一键采纳所有建议

#### 补充项智能排序
1. **必填项**（高亮显示）
   - 缺失的关键信息
   - 执行频率和时长
   
2. **建议项**（默认展开）
   - 提醒时间
   - 打卡方式
   - 里程碑设置
   
3. **可选项**（折叠状态）
   - 见证人邀请
   - 奖惩机制
   - 高级设置

### 4. 里程碑自动生成

#### 生成规则
```yaml
短期目标（1-7天）:
  - 按天拆分
  - 每日具体任务
  
中期目标（1-4周）:
  - 按周拆分
  - 每周阶段目标
  
长期目标（1-12月）:
  - 按月拆分
  - 月度里程碑

示例:
  输入: "一个月减重5公斤"
  生成:
    - 第1周: 减重1.5公斤，建立运动习惯
    - 第2周: 减重1.5公斤，优化饮食结构
    - 第3周: 减重1公斤，强化有氧运动
    - 第4周: 减重1公斤，巩固成果
```

### 5. TODO智能拆分

#### 拆分维度
- **时间维度**：每日/每周/每月任务
- **内容维度**：主任务/子任务/可选任务
- **优先级**：必做/建议/可选

#### 示例
```yaml
约定: "每天学英语30分钟"
TODO生成:
  每日必做:
    - 背诵10个新单词（10分钟）
    - 复习昨日单词（5分钟）
    - 口语练习（10分钟）
    - 听力训练（5分钟）
  
  每周建议:
    - 完成一篇阅读理解
    - 观看一集美剧
    - 参加口语角活动
  
  每月目标:
    - 掌握300个单词
    - 能进行5分钟对话
```

### 6. 手动模式AI辅助

#### 触发时机
- 用户选择手动创建
- 填写表单过程中
- 保存前的优化建议

#### 辅助方式
- **实时提示**：输入时显示相关建议
- **智能补全**：根据已填信息推断其他字段
- **优化建议**：💡图标提示可改进项
- **一键优化**：应用所有AI建议

## 五、基础模式与AI模式对比

### 功能对比

| 功能 | 基础模式 | AI模式（Kimi API） |
|------|---------|---------|
| 创建约定 | ✅ 手动填写表单 | ✅ 对话式创建 |
| 选择模板 | ✅ 固定模板库 | ✅ 智能推荐 |
| 约定管理 | ✅ 完整功能 | ✅ 完整功能 |
| 打卡执行 | ✅ 完整功能 | ✅ 完整功能 |
| 见证人 | ✅ 完整功能 | ✅ 完整功能 |
| 通知提醒 | ✅ 完整功能 | ✅ 完整功能 |
| 自然语言理解 | ❌ 不支持 | ✅ 支持 |
| 内容优化建议 | ❌ 不支持 | ✅ 支持 |
| 个性化推荐 | ❌ 基础推荐 | ✅ 智能推荐 |
| 冲突检测 | ❌ 不支持 | ✅ 智能检测 |
| 离线使用 | ✅ 完全离线 | ⚠️ 需要网络 |

### 基础模式保障
- 完整的表单创建流程
- 丰富的固定模板库
- 基于规则的推荐
- 所有核心功能可用

### AI增值体验
- 自然语言输入
- 智能内容生成
- 个性化推荐
- 冲突预警提醒

## 六、用户引导策略

### AI功能推广时机
1. **首次启动**：新手引导中介绍
2. **创建约定时**：展示AI简化优势
3. **使用模板时**：对比智能推荐
4. **设置页面**：提供功能开关

### 价值传达方式
- 功能对比展示
- 成功案例分享
- 免费体验额度
- 用户testimonial

### MVP阶段说明
- AI功能需要网络连接
- 每月免费额度（如100次）
- 超出后可购买套餐
- 后续版本支持离线

## 七、错误处理机制

### API调用失败处理
- 自动重试机制（3次）
- 降级到基础模式
- 友好错误提示
- 缓存结果复用

### 网络异常处理
- 离线检测提醒
- 基础功能可用
- 队列缓存请求
- 恢复后自动处理

### 限流处理
- 用户级限流提示
- 引导升级套餐
- 显示剩余额度
- 降级基础功能

## 八、隐私与安全

### MVP阶段数据保护（API方式）
- **数据加密传输**：HTTPS加密通信
- **最小化原则**：只传输必要信息
- **匿名化处理**：去除个人身份信息
- **不存储用户数据**：API不保留用户内容
- **合规性**：遵守隐私保护法规

### 未来端侧模型隐私优势
- **本地推理**：所有AI计算在设备端完成
- **不上传云端**：用户数据不离开设备
- **加密存储**：推理结果加密保存
- **用户可控**：随时删除模型和数据

### 内容安全措施
- 敏感信息自动过滤
- 不当内容识别拦截
- 儿童内容保护
- 合规性检查

## 九、监控与优化

### 关键指标监控（MVP阶段）
- AI功能使用率
- API调用成功率
- 响应时间统计
- 缓存命中率
- 用户满意度
- Token消耗统计
- 成本监控

### 持续优化方向
- Prompt优化降低成本
- 缓存策略提升性能
- 功能体验改进
- 用户反馈响应

## 十、实施计划

### MVP阶段（1-2个月）
1. **Week 1-2**：Kimi API接入开发
   - 申请API Key
   - 开发后端中转服务
   - 实现基础调用封装
   
2. **Week 3-4**：核心功能开发
   - AI快速创建功能
   - 智能信息提取
   - 内容优化建议
   
3. **Week 5-6**：平台适配
   - 微信小程序云函数
   - H5后端API
   - RN接入调试
   
4. **Week 7-8**：优化与测试
   - 性能优化
   - 成本控制
   - 用户体验测试

### V2.0阶段（3-6个月后）
- 评估端侧模型需求
- 选择合适的轻量级模型
- 实现端侧推理框架
- 云端+端侧混合方案

## 十一、总结

### 核心设计理念
**MVP先用云端API快速验证，后续演进到端侧保护隐私**

### 关键决策点
1. **MVP选择**：Kimi k2 API，快速上线
2. **成本控制**：合理的免费额度+付费模式
3. **基础保障**：无AI仍可完整使用
4. **隐私保护**：数据最小化+加密传输
5. **体验分级**：基础功能+AI增强

### 成功要素
- 清晰的价值主张
- 低成本快速验证
- 可靠的基础模式
- 持续的优化迭代
- 平滑的升级路径

---

*设计版本：v2.0*  
*更新日期：2025-08-09*  
*状态：MVP使用API，后续支持端侧*